# Ð¡ÑÑ‹Ð»ÐºÐ¸

- Ð’ÑÐµÐ³Ð¾ ÑÑÑ‹Ð»Ð¾Ðº: 31

## Ð¡ÑÑ‹Ð»ÐºÐ¸

- [Bitfield Consulting](https://bitfieldconsulting.com/posts/slow-flaky-failing) ðŸ‘¤ Bitfield Consulting ðŸ’¬ 44 ðŸ”– #go, #testing ðŸ—“ï¸ 2025-02-01
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Bitfield Consulting offers friendly mentoring for Go and Rust programming languages. You can join their Code Club to receive free learning resources and special offers. Unsubscribing from the mailing list is easy at any time.
- [Mocking Techniques for Go](https://www.myhatchpad.com/insight/mocking-techniques-for-go/) ðŸ‘¤ Hatchpad ðŸ’¬ 1650 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-12-24
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The article discusses various mocking techniques for unit testing in Go to ensure tests are fast and reliable. It covers methods like Higher-Order Functions, Monkey Patching, and Interface Substitution, each suited for different testing scenarios. The author emphasizes that with the right approaches, no code should be considered "untestable."
- [Property Testing: Beyond Matching Input-Output Pairs](https://appliedgo.net/spotlight/property-testing/) ðŸ‘¤ Applied Go ðŸ’¬ 469 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-12-09
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Property testing focuses on the inherent properties of functions rather than specific input-output pairs. It ensures that certain conditions hold true for all inputs, like a function returning unchanged output for already processed data. This testing method complements traditional unit tests, making the overall testing more thorough.
- [Implement Unit Test for CLI Apps using Golang and Cobra](https://clavinjune.dev/en/blogs/implement-unit-test-for-cli-apps-using-golang-and-cobra/) ðŸ‘¤ Clavin June ðŸ’¬ 1143 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-12-09
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This blog post explains how to implement unit tests for CLI applications built with Golang and the Cobra library. It emphasizes the importance of test-driven development (TDD) for creating better, more reliable code. The article provides practical examples of modifying Cobra code to make it testable and creating test cases for different command scenarios.
- [Effective Python Testing With Pytest](https://realpython.com/pytest-python-testing/) ðŸ‘¤ Dane Hillard ðŸ’¬ 5149 ðŸ”– #pytest, #python, #testing ðŸ—“ï¸ 2024-12-09
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This tutorial teaches you how to effectively use pytest for testing your Python code. It covers features like fixtures for managing test state, marks for categorizing tests, and parametrization to reduce code duplication. Pytest simplifies testing with clear output and a flexible plugin system, making it a powerful tool for both new projects and existing unittest suites.
- [How to Fuzz Test Golang HTTP Services](https://www.freecodecamp.org/news/how-to-fuzz-test-golang-http-services/) ðŸ‘¤ freeCodeCamp.org ðŸ’¬ 1547 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-11-07
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Fuzz testing is a technique used in software development to find bugs by inputting random or unexpected data into programs. In Go, fuzz testing has been integrated into the standard library since version 1.18, allowing developers to easily test their functions and HTTP services for potential vulnerabilities. This method helps identify hard-to-find issues that traditional testing might miss, improving overall software reliability.
- [Jeff Triplett's Micro.blog - How to test with Django and pytest fixtures](https://micro.webology.dev/2024/02/05/how-to-test.html) ðŸ‘¤ Jeff Triplett ðŸ’¬ 351 ðŸ”– #django, #pytest, #testing ðŸ—“ï¸ 2024-02-08
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Here are some notes on how I like to write tests for a Django app that tests a model down to a view.
Django Model + pytest Fixture This part is a mouthful, but I prefer to use the Model Bakery library to automatically create instances of Django models (aka a fixture) with good test data instead of manually creating them. This approach saves time and adds some variety to my test data.
- [Three pytest Features You Will Love | The PyCharm Blog](https://blog.jetbrains.com/pycharm/2024/02/pytest-features/) ðŸ‘¤ Helen Scott ðŸ’¬ 840 ðŸ”– #pytest, #python, #testing ðŸ—“ï¸ 2024-02-13
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Pytest is a popular Python framework that offers several features. This article highlights three of these features: fixtures, markers, and parametrize. Fixtures allow for the setup and teardown of resources and conditions in a consistent and repeatable way. Markers provide the ability to selectively run or skip tests based on certain conditions. Parametrize allows for running the same test with different input parameters. These features enhance code reusability, test organization, and test flexibility.
- [Testing with Python (part 2): moving to pytest](https://www.bitecode.dev/p/testing-with-python-part-2-moving) ðŸ‘¤ Bite Code! ðŸ’¬ 1922 ðŸ”– #pytest, #testing ðŸ—“ï¸ 2024-04-08
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text discusses transitioning from using the unittest framework in Python to using pytest for testing. pytest is praised for making testing easier, more flexible, and faster. The text provides examples of converting unittest code to pytest code and highlights the benefits of using fixtures in pytest for setup and teardown operations.
- [Testing with Python (part 3): pytest setup - Bite code!](https://www.bitecode.dev/p/testing-with-python-part-3-pytest) ðŸ‘¤ Bite Code! ðŸ’¬ 2538 ðŸ”– #pytest, #python, #testing ðŸ—“ï¸ 2024-04-26
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text explains how to set up and configure pytest for testing Python code. It covers organizing test files, defining fixtures, and configuring pytest behavior using pyproject.toml and conftest.py files. By following the guidelines provided, users can streamline test execution, manage imports, and leverage pytest features effectively.
- [Testing with Python (part 4): why and what to test?](https://www.bitecode.dev/p/testing-with-python-part-4-why-and) ðŸ‘¤ Bite Code! ðŸ’¬ 3052 ðŸ”– #testing ðŸ—“ï¸ 2024-05-13
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Testing in Python involves understanding the reasons for testing and deciding what to test based on those reasons. Different purposes of testing include avoiding regressions, managing quality, and matching specifications. Testing takes time and effort but is crucial for ensuring the reliability and quality of software.
- [Django: Test for pending migrations - Adam Johnson](https://adamj.eu/tech/2024/06/23/django-test-pending-migrations/) ðŸ‘¤ adamj.eu ðŸ’¬ 601 ðŸ”– #try, #django, #testing ðŸ—“ï¸ 2024-06-23
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Always test for pending migrations in Django to ensure model changes are reflected in database migrations before deployment. You can use the makemigrations command with --dry-run and --check flags to detect any missing migrations. Consider incorporating a test within your project to automatically check for pending migrations and prevent deployment issues.
- [GoMock vs. Testify: Mocking frameworks for Go](https://www.codecentric.de/wissens-hub/blog/gomock-vs-testify) ðŸ‘¤ Sergey Grebenshchikov ðŸ’¬ 2867 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-09-01
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** A comparison of popular Go mocking frameworks: Testify/mock and GoMock. We look at mock generation and usage, type safety, output for failing tests, and integration with Go tooling.
- [Python Testing Part 1: isolating external calls and minimising mocks](https://simoncrowe.hashnode.dev/python-testing-part-1-isolating-external-calls-and-minimising-mocks) ðŸ‘¤ Simon Crowe ðŸ’¬ 1323 ðŸ”– #python, #testing ðŸ—“ï¸ 2024-09-08
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Mocks are a necessary evil in Python testing. If overused, they essentially become "change detectors", meaning that every time you refactor the implementation of your code, you must update the mocks too. Ideally, your tests should verify what your co...
- [Python Testing Part 2: Dependency Inversion with Service Functions](https://simoncrowe.hashnode.dev/python-testing-part-2-dependency-inversion-with-service-functions) ðŸ‘¤ Simon Crowe ðŸ’¬ 907 ðŸ”– #python, #testing ðŸ—“ï¸ 2024-09-23
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This article discusses using dependency inversion in Python testing to avoid excessive mocking in I/O operations. It emphasizes that service functions should use lightweight implementations of interfaces instead of mocks for better clarity and simplicity. The author shares insights on testing techniques and the benefits of keeping functions pure and focused.
- [Learn Go with Tests | Learn Go with tests](https://quii.gitbook.io/learn-go-with-tests) ðŸ‘¤ quii.gitbook.io ðŸ’¬ 125 ðŸ”– #go, #tdd, #testing ðŸ—“ï¸ 2024-09-30
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The writer has experience introducing Go to development teams and wants to create something useful for other teams. They mention a book that requires a high level of commitment and suggest learning the fundamentals by writing small tests and using existing software design skills to create great systems.
- [Google Testing Blog: SMURF: Beyond the Test Pyramid](https://testing.googleblog.com/2024/10/smurf-beyond-test-pyramid.html?m=1) ðŸ‘¤ testing.googleblog.com ðŸ’¬ 397 ðŸ”– #testing ðŸ—“ï¸ 2024-10-16
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The test pyramid helps guide how to create a balanced test suite by suggesting more unit tests than integration tests, and more integration tests than end-to-end tests. However, as test suites grow, it's important to consider trade-offs using the SMURF mnemonic, which stands for Speed, Maintainability, Utilization, Reliability, and Fidelity. Balancing these dimensions can help improve the effectiveness and efficiency of your testing process.
- [Testing API Libraries - Calhoun.io](https://www.calhoun.io/testing-api-libraries/) ðŸ‘¤ Jon Calhoun ðŸ’¬ 1524 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-10-23
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text discusses testing API libraries and highlights the importance of using integration tests when working with APIs. It suggests starting with integration tests to ensure code works with the real API and emphasizes using convention over configuration for setting up local test servers. Additionally, it mentions the value of writing unit tests for complex encoding and decoding scenarios in API libraries.
- [Suite smells: testing legacy code â€” Bitfield Consulting](https://bitfieldconsulting.com/posts/testing-legacy-code) ðŸ‘¤ John Arundel ðŸ’¬ 37 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-11-04
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The article discusses the challenges of testing legacy code in software development. It emphasizes the importance of understanding existing codebases to improve them. The author also offers resources for learning Go and Rust.
- [What is Testcontainers, and why should you use it?](https://testcontainers.com/guides/introducing-testcontainers/) ðŸ‘¤ Testcontainers ðŸ’¬ 860 ðŸ”– #docker, #testing ðŸ—“ï¸ 2025-05-15
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Testcontainers is a testing library that simplifies integration testing by allowing developers to use real services in Docker containers instead of mocks or in-memory databases. It helps avoid issues like data conflicts and the need for pre-provisioned infrastructure, enabling faster and more reliable testing. With Testcontainers, you can run integration tests seamlessly alongside unit tests in various programming languages.
- [Getting started with Testcontainers for Python](https://testcontainers.com/guides/getting-started-with-testcontainers-for-python/) ðŸ‘¤ Testcontainers ðŸ’¬ 1181 ðŸ”– #docker, #python, #testing ðŸ—“ï¸ 2025-05-15
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Testcontainers is an open-source framework that allows developers to easily create and manage temporary Docker containers for testing applications, such as using a PostgreSQL database. By integrating Testcontainers with Python, developers can run tests against a real database instead of using mocks, ensuring more reliable results. This guide walks through creating a Python application, setting up a PostgreSQL database, and writing tests using Testcontainers.
- [Why Writing Quality Tests Matters More Than Ever](https://alexbunardzic.substack.com/p/why-writing-quality-tests-matters) ðŸ‘¤ Alex Bunardzic ðŸ’¬ 1542 ðŸ”– #llm, #testing ðŸ—“ï¸ 2025-03-20
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Writing quality tests is essential for software development as it ensures code correctness and maintainability. Test Driven Development (TDD) allows developers to refactor code confidently without risking existing functionality. Although using AI to generate code might seem appealing, the lack of maintainability in the produced code raises concerns about future human oversight.
- [Dec 8 Suite smells: undertesting and overtesting](https://bitfieldconsulting.com/posts/undertesting-overtesting) ðŸ‘¤ John Arundel ðŸ’¬ 2165 ðŸ”– #go, #outline, #testing ðŸ—“ï¸ 2024-12-08
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The author discusses the importance of testing not just if code works, but also ensuring it doesn't produce unwanted results. He highlights that tests should check both preconditions and postconditions to avoid misleading outcomes. Additionally, he warns against overtesting, which can make tests unnecessarily complex and fragile.
- [Making Use of Code Coverage | Epic Web Dev](https://www.epicweb.dev/making-use-of-code-coverage) ðŸ‘¤ Artem Zakharchenko ðŸ’¬ 2018 ðŸ”– #testing ðŸ—“ï¸ 2024-02-14
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Code coverage is a metric that measures how much of a tested system is run during testing. It can be a useful tool for identifying missed logic, dead code, and gaining more context on what is being tested in an application. However, code coverage should not be the sole driver of testing efforts and should be approached with caution. It is important to prioritize intention-driven testing and understand the limitations and caveats of code coverage. Misuse of code coverage can lead to unreliable results and misguided testing strategies. Ultimately, code coverage should be used as a tool to aid in auditing software and finding problematic areas, rather than as a metric to drive testing decisions.
- [The True Purpose of Testing | Epic Web Dev](https://www.epicweb.dev/the-true-purpose-of-testing) ðŸ‘¤ Artem Zakharchenko ðŸ’¬ 644 ðŸ”– #testing ðŸ—“ï¸ 2024-02-15
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The true purpose of automated tests is to validate the intention behind the system. Tests become useful when they focus on the intention rather than the implementation. Many tests fail to fulfill their purpose because they focus on implementation details instead of validating what the code is intended to do. By treating implementation details as a means to an end and focusing on the larger intention at hand, the value of automated testing can be unlocked. It is important to always test the intention behind the system to ensure that it functions without fault.
- [Common Testing Mistakes](https://kentcdodds.com/blog/common-testing-mistakes) ðŸ‘¤ kentcdodds.com ðŸ’¬ 992 ðŸ”– #testing ðŸ—“ï¸ 2024-02-15
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text discusses common testing mistakes, such as testing implementation details and aiming for 100% code coverage, which may not necessarily increase confidence in the codebase. The author emphasizes the importance of writing tests that focus on critical parts of the application to ensure confidence, rather than just increasing code coverage. Additionally, the text highlights the need for efficient end-to-end testing strategies to enhance test reliability and speed.
- [Testing Implementation Details](https://kentcdodds.com/blog/testing-implementation-details) ðŸ‘¤ kentcdodds.com ðŸ’¬ 2145 ðŸ”– #testing ðŸ—“ï¸ 2024-02-15
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Testing implementation details can lead to fragile tests that break easily when code changes. It's better to write tests that focus on how the software behaves from a user's perspective, rather than its internal workings. Using tools like React Testing Library helps create more reliable tests that are resilient to changes in the implementation.
- [Improve your tests in Django with fakes and factories](https://www.hacksoft.io/blog/improve-your-tests-django-fakes-and-factories) ðŸ‘¤ hacksoft.io ðŸ’¬ 1112 ðŸ”– #faker, #django, #testing, #factory-boy ðŸ—“ï¸ 2024-05-02
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** In this article, we show how to up your Django testing game, by using fakes & factories.
- [Testing with Python (part 7): ...until you make it](https://www.bitecode.dev/p/testing-with-python-part-7-until) ðŸ‘¤ Bite Code! ðŸ’¬ 2729 ðŸ”– #try, #pytest, #python, #testing ðŸ—“ï¸ 2024-06-22
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This article discusses generating test data in Python using seeding for consistency and the mimesis library for creating fake data. It emphasizes the importance of reproducibility in tests and introduces techniques like snapshotting to simplify testing. By using these methods, developers can efficiently create diverse and realistic test data without hardcoding.
- [Testing with Python (part 6): Fake it... - Bite code!](https://www.bitecode.dev/p/testing-with-python-part-6-fake-it) ðŸ‘¤ Bite Code! ðŸ’¬ 1868 ðŸ”– #python, #testing ðŸ—“ï¸ 2024-06-23
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text discusses testing Python code using mocks and integration tests. Mocks can fake behavior and record calls made to them during testing. Using mocks can help create isolated and efficient unit tests.
- [Testing is Not for Beginners - Calhoun.io](https://www.calhoun.io/testing-is-not-for-beginners/) ðŸ‘¤ Jon Calhoun ðŸ’¬ 1742 ðŸ”– #go, #testing ðŸ—“ï¸ 2024-09-04
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Everyone keeps saying you should be testing, but are they right? In this article we discuss the downsides to trying to learn testing too early and how it can negatively affect your ability to learn to code.
