# Ð¡ÑÑ‹Ð»ÐºÐ¸

- Ð’ÑÐµÐ³Ð¾ ÑÑÑ‹Ð»Ð¾Ðº: 12

## Ð¡ÑÑ‹Ð»ÐºÐ¸

- [Effective Python Testing With Pytest](https://realpython.com/pytest-python-testing/) ðŸ‘¤ Dane Hillard ðŸ’¬ 5149 ðŸ”– #pytest, #python, #testing ðŸ—“ï¸ 2024-12-09
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This tutorial teaches you how to effectively use pytest for testing your Python code. It covers features like fixtures for managing test state, marks for categorizing tests, and parametrization to reduce code duplication. Pytest simplifies testing with clear output and a flexible plugin system, making it a powerful tool for both new projects and existing unittest suites.
- [Jeff Triplett's Micro.blog - How to test with Django and pytest fixtures](https://micro.webology.dev/2024/02/05/how-to-test.html) ðŸ‘¤ Jeff Triplett ðŸ’¬ 351 ðŸ”– #django, #pytest, #testing ðŸ—“ï¸ 2024-02-08
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Here are some notes on how I like to write tests for a Django app that tests a model down to a view.
Django Model + pytest Fixture This part is a mouthful, but I prefer to use the Model Bakery library to automatically create instances of Django models (aka a fixture) with good test data instead of manually creating them. This approach saves time and adds some variety to my test data.
- [Three pytest Features You Will Love | The PyCharm Blog](https://blog.jetbrains.com/pycharm/2024/02/pytest-features/) ðŸ‘¤ Helen Scott ðŸ’¬ 840 ðŸ”– #pytest, #python, #testing ðŸ—“ï¸ 2024-02-13
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Pytest is a popular Python framework that offers several features. This article highlights three of these features: fixtures, markers, and parametrize. Fixtures allow for the setup and teardown of resources and conditions in a consistent and repeatable way. Markers provide the ability to selectively run or skip tests based on certain conditions. Parametrize allows for running the same test with different input parameters. These features enhance code reusability, test organization, and test flexibility.
- [Testing with Python (part 2): moving to pytest](https://www.bitecode.dev/p/testing-with-python-part-2-moving) ðŸ‘¤ Bite Code! ðŸ’¬ 1922 ðŸ”– #pytest, #testing ðŸ—“ï¸ 2024-04-08
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text discusses transitioning from using the unittest framework in Python to using pytest for testing. pytest is praised for making testing easier, more flexible, and faster. The text provides examples of converting unittest code to pytest code and highlights the benefits of using fixtures in pytest for setup and teardown operations.
- [(1) Developing and Testing an Asynchronous API with FastAPI and Pytest | TestDriven.io](https://testdriven.io/blog/fastapi-crud/) ðŸ‘¤ Michael Herman ðŸ’¬ 4138 ðŸ”– #pytest, #fastapi ðŸ—“ï¸ 2024-04-09
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This tutorial explains how to create and test an asynchronous API with FastAPI, Postgres, pytest, and Docker using Test-driven Development (TDD). It covers developing handlers, setting up Postgres, testing with pytest, and containerizing with Docker. FastAPI is highlighted as a high-performance Python web framework for building RESTful APIs.
- [Testing with Python (part 3): pytest setup - Bite code!](https://www.bitecode.dev/p/testing-with-python-part-3-pytest) ðŸ‘¤ Bite Code! ðŸ’¬ 2538 ðŸ”– #pytest, #python, #testing ðŸ—“ï¸ 2024-04-26
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** The text explains how to set up and configure pytest for testing Python code. It covers organizing test files, defining fixtures, and configuring pytest behavior using pyproject.toml and conftest.py files. By following the guidelines provided, users can streamline test execution, manage imports, and leverage pytest features effectively.
- [Testing with Python (part 9): the extra mile](https://www.bitecode.dev/p/testing-with-python-part-9-the-extra) ðŸ‘¤ Bite Code! ðŸ’¬ 2004 ðŸ”– #pytest ðŸ—“ï¸ 2024-08-07
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** You can improve your Python testing by using pytest-cov to measure test coverage and ensure all code is executed. Tools like nox help you test across multiple Python versions and library combinations to verify compatibility. This process allows you to set minimum coverage requirements and efficiently run tests in various environments.
- [How To Mock In Pytest? (A Comprehensive Guide) | Pytest with Eric](https://pytest-with-eric.com/mocking/pytest-mocking/) ðŸ‘¤ pytest-with-eric.com ðŸ’¬ 2392 ðŸ”– #pytest ðŸ—“ï¸ 2024-08-07
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This guide explains how to use mocking in Pytest to isolate tests from external dependencies. It covers setting up a project structure, using the pytest-mock plugin, and provides examples of mocking functions, methods, and classes. Mocking helps ensure tests run smoothly without relying on external services or changing file systems.
- [Python Friday #239: Asynchronous Tests With Pytest - Improve & Repeat](https://improveandrepeat.com/2024/08/python-friday-239-asynchronous-tests-with-pytest/) ðŸ‘¤ Johnny Graber ðŸ’¬ 443 ðŸ”– #pytest ðŸ—“ï¸ 2024-08-13
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** None
- [Python Friday #240: Asynchronous SQLAlchemy With FastAPI - Improve & Repeat](https://improveandrepeat.com/2024/08/python-friday-240-asynchronous-sqlalchemy-with-fastapi/) ðŸ‘¤ Johnny Graber ðŸ’¬ 1550 ðŸ”– #pytest, #fastapi, #sqlalchemy ðŸ—“ï¸ 2024-08-17
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** None
- [How To Run A Single Test In Pytest (Using CLI And Markers) | Pytest with Eric](https://pytest-with-eric.com/introduction/pytest-run-single-test/) ðŸ‘¤ pytest-with-eric.com ðŸ’¬ 1333 ðŸ”– #pytest ðŸ—“ï¸ 2024-08-31
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** Youâ€™ve written code and Unit tests, and want to make sure it works. You simply run the pytest command in your terminal to run them the tests. Boom! some tests fail. How do you debug it? To debug, itâ€™
- [Testing with Python (part 7): ...until you make it](https://www.bitecode.dev/p/testing-with-python-part-7-until) ðŸ‘¤ Bite Code! ðŸ’¬ 2729 ðŸ”– #try, #pytest, #python, #testing ðŸ—“ï¸ 2024-06-22
    > **Ð ÐµÐ·ÑŽÐ¼Ðµ:** This article discusses generating test data in Python using seeding for consistency and the mimesis library for creating fake data. It emphasizes the importance of reproducibility in tests and introduces techniques like snapshotting to simplify testing. By using these methods, developers can efficiently create diverse and realistic test data without hardcoding.
